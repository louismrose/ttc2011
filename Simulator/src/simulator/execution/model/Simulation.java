/*******************************************************************************
 * Copyright (c) 2011 The University of York.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Louis Rose - initial API and implementation
 ******************************************************************************/
package simulator.execution.model;

import java.io.IOException;
import java.io.Serializable;
import java.util.Collection;

import simulator.config.Configuration;
import simulator.config.Mode;
import simulator.config.UnitOfTime;
import simulator.config.Variable;
import simulator.execution.model.actions.RunnableActionGroup;
import simulator.execution.model.state.State;
import simulator.execution.model.state.StateObserver;
import simulator.execution.model.state.VariableWithValue;
import simulator.persistence.SerializableConfiguration;
import simulator.trace.Trace;

public class Simulation implements Serializable {

	// Generated by Eclipse
	private static final long serialVersionUID = 8378817217535302346L;
	
	private final SerializableConfiguration configuration;
	private final State state;
	
	private transient Modes modes;
	
	public Simulation(Configuration configuration) throws IOException {
		this.configuration = new SerializableConfiguration(configuration);
		this.state = new State(configuration.getModes().size());
			
		initialiseVariables();
		scheduleEvents();
		initialiseFirstMode();
	}

	private void initialiseVariables() {
		for (Variable variable : configuration.getVariables()) {
			state.initialiseValueOf(variable);
		}
	}
	
	private void scheduleEvents() {
		this.state.addObserver(new StateObserver() {
			
			@Override
			public void stateChanged(State state) {
				// If any of the events edit the state, we will be notified
				// and try to invoke the events again, so we turn off
				// notifications while the events are running
				state.removeObserve(this);
				new RunnableActionGroup(configuration.getEvents()).run(state);
				state.addObserver(this);
			}
		});
	}
	
	private void initialiseFirstMode() {
		getModes().modeChanged(state);
	}

	private Modes getModes() {
		if (modes == null) {
			this.modes = new Modes(configuration.getModes());
			state.addModeObserver(modes);
		}
		
		return modes;
	}
	
	public Mode getCurrentMode() {
		return getModes().getCurrentMode(state);
	}

	public String getDisplayText() {
		return state.getDisplayText();
	}
	
	public String getIndicatorText() {
		return state.getIndicatorText();
	}
	
	public String getAlarmStatus() {
		return state.isAlarmRinging() ? "ringing" : "silent";
	}
	
	public Trace getTrace() {
		return state.getTrace();
	}
	
	public void pressButton(int buttonIndex) {
		getModes().pressButton(buttonIndex, state);
	}
	
	public Collection<VariableWithValue> getVariableValues() {
		return state.getVariableValues();
	}

	public void incrementVariable(String variableName, UnitOfTime unit) {
		state.incrementValueOf(variableName, unit);
	}

	public Time getValueOf(String variableName) {
		return state.getValueOf(variableName);
	}
}